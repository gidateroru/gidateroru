<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>
        
        State Management Pattern nedir? Neden Kullanılır?
        
    </title>

    
    <link rel='stylesheet' href='/assets/css/simple-grid.min.css' type='text/css'>
    <link rel='stylesheet' href='/assets/css/syntax.css' type='text/css'>
    

    <meta name='viewport' content='width=device-width, initial-scale=1'>

</head>

<body>
    <header>
    <h1><a href='/'>Gıda Terörü</a></h1>
</header>
<a href='/'> Anasayfa</a> | <a href='/archive/'> Arşiv</a>
<hr>

    <h1>State Management Pattern nedir? Neden Kullanılır?</h1>
<div class='separator'></div>
        
<p>Geniş çaplı uygulamaların karmaşıklık seviyesi, projenin büyüme hızıyla doğru orantılıdır. Özellikle proje javascript gibi bir dil ile geliştiriliyorsa <code class="highlighter-rouge">state management</code> gibi design pattern‘ların kullanımı zorunluluk hale geliyor.</p>

<p>UI <code class="highlighter-rouge">(user interface)</code> için kullanabileceğimiz bir çok framework’ün (<code class="highlighter-rouge">Angular</code>, <code class="highlighter-rouge">VueJS</code>, <code class="highlighter-rouge">React</code>, <code class="highlighter-rouge">React Native</code>) piyasaya çıkmasıyla yeni yöntemlerin uygulanmasına bağlı olarak bir takım sorunlar da beraberinde geldi. Bunlardan en önemlisi nesneler (objects), diziler (arrays) ve ilkel (primitive) türler dediğimiz <code class="highlighter-rouge">string</code>, <code class="highlighter-rouge">boolean</code> ve <code class="highlighter-rouge">number</code> türlerinin değişmezlik <code class="highlighter-rouge">(immutable)</code> yönetimleridir.</p>

<p>Kod performansını yüksek tutmak için mutable/immutable konusu önemli bir konudur. Bir <code class="highlighter-rouge">&lt;x-component&gt;</code>‘i içinde kullandığınız değişken <code class="highlighter-rouge">&lt;y-component&gt;</code>‘i için de değişme (mutate) riski taşıyacağından bu da beraberinde bir takım bug’ları getiriyor olacaktır. Bu tür sorunların debugging işlemi bir hayli sancılı olmaktadır.</p>

<p>Bir değişkeni reference olarak değil yeni bir kopyasını (clone) oluşturarak farklı yerlerde kullanılması çok daha doğru bir adım olacaktır. Immutable kavramının tam olarak tanımı için; “Herhangi bir türe sahip değişkenin değerini asla değiştirme. Yeni bir kopyasını oluştur ve kullan.” şeklinde açıklayabiliriz.</p>

<p>Neden peki değişkenleri istediğimiz yerde istediğimiz şekilde kullanamıyoruz yada değiştiremiyoruz? Aslında bu sorunun cevabı kullandığımız UI framework’lerin <code class="highlighter-rouge">data-bind</code> mimarisi üzerine kurulu olmasıyla ilgili bir durum. Özetle component içinde bir değişken ile html elementini birbirine bağlayarak (binding) arada bir ilişki kuruluyor. Bu iki uç nokta sürekli olarak birbirleriyle etkileşim içinde oluyorlar.</p>

<blockquote>
  <p>Not: Data-Binding iki yönlü (two-way) ya da tek yönlü (one-way) olabilir. Kullanılan teknolojiye göre farklılık gösterebilir. İki yönlü binding mimarisi, bind edilen değişken mevcut değerinden farklı bir değer ile değiştirilirse bu değişim direkt olarak UI’a yansıyacaktır. Aynı şekilde UI tarafında bir input yada vb. form element ile bind edilmiş ise bu elemente girilecek olan her değer direkt olarak değişkeni etkileyecektir.</p>
</blockquote>

<p>Bind edilmiş bir değişken ile element her hangi bir değişime karşı birbirlerini sürekli dinliyor olacaklardır. Bir değişkenin değeri her değiştiğinde direkt olarak componentin kendini tekrar render etmesini sağlayacaktır. Peki ama aynı değişken bir den fazla component için de aynı referans ile kullanıldığında olacakları bir düşünün? Tek bir değişkenin mutate olması bir çok componenti tekrar tekrar render olmaya zorlayacaktır. Bu durum performans sorunlarını beraberinde getirecektir.</p>

<p>Yukarıdaki hata senaryolarının çözümü state management kullanımında yatmaktadır. Neyseki bir çok framework bu pattern’ı kendi bünyelerine entegre ederek kullanımını teşvik etmektedir. Aksi halde frensiz bir arabayla yolculuk yapmak gibi riskli bir geliştirme süreci kaçınılmaz olacaktır.</p>

<h2 id="temel-özellikleri">Temel özellikleri</h2>

<p>State management temel de 3 farklı bileşini vardır. Bunlar;</p>

<ul>
  <li>Store</li>
  <li>Actions</li>
  <li>Reducers</li>
</ul>

<h2 id="store">Store</h2>
<p>Store tüm değişkenlerin muhafaza edileceği (in-memory) kısım. Veriler buraya kaydedilip kullanılmak istenildiğin de tekrar buradan elde edilecektir.</p>

<h2 id="actions">Actions</h2>
<p>Bir değişken/sabit yada class olarak kullanılabilmektedir. Store ile veri alışverişi yapılırken her işlemi temsil edecek olan bir kimlik olarak düşünebiliriz. Genel de açıklayıcı niteliği taşıyan değerler atanır.</p>

<p><strong>Örnek:</strong></p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">REMOVE_ITEM_ACTION</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">[Todo] Remove item</span><span class="dl">'</span>
</code></pre></div></div>

<h2 id="reducers">Reducers</h2>
<p>Reducer aşaması store’daki veriyi işleme görevini yapacak olan kısımdır. Action’lar ile iletişim kurar ve mutate işlemlerini gerçekleştirir. Daha sonra veriyi tekrar store’a yazar ve yeni bir kopyasını kullanılmak üzere geri döndürür.</p>

<h2 id="avantajları">Avantajları</h2>
<p>En büyük avantajı hiç şüphesiz in-memory veri yığınının daha tutarlı kullanımına imkan sağlaması. Yazının girişin de bahsettiğimiz gibi büyük ölçekli projeler de en büyük risk immutable yönetemidir.</p>

<p>Bir diğer avantaj cache imkanı sunuyor olması. Browser ortamın da çalışan sistemler de store’a eklenen verilerin tekrar API sorgusuna gerek kalmadan kullanılabilir olmasıdır.</p>

<h2 id="dezavantajları">Dezavantajları</h2>
<p>Avantaj olarak gördüğümüz cache’leme kolaylığı iyi yönetilemezse dezavantaj olarak önümüze geri gelecektir. Çok fazla kaynak tüketimi (memory leak) olacağından tarayıcı ortamında (özellikle mobil tarayıcılar da) ciddi performans sorunlarına yol açabilir.</p>

<h2 id="sonuç">Sonuç</h2>
<p>Sonuç olarak client (özellikle SPA) projeler de kullanmamız faydalı olacaktır. Avantajları ve dezavantajlarının göz önünde bulundurulması gerektiğini unutmamalıyız.</p>

<p>Günümüz tarayıcılarının imkanları geniş ve modern teknolojilere hızlıca destek veriyor olsalar da sınırsız olmadığını unutmamak lazım.</p>

<p>Aşağıda her hangi bir framework’e bağımlı kalmadan kullanabileceğiniz bir kaç State Management library repo’ları paylaştım.</p>

<p><a href="https://redux.js.org/">https://redux.js.org/</a></p>

<p><a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a></p>

<p><a href="https://github.com/mobxjs/mobx">https://github.com/mobxjs/mobx</a></p>

        



    <hr>
    <p><small> <i>Ne yediğine dikkat et...</i> </small></p>
</body>

</html>